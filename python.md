## 基本数据类型

Python还允许用`r''`表示`''`内部的字符串默认不转义

布尔值可以用`and`、`or`和`not`运算


== 元素符比较两个对象的值（对象中保存的数据），is比较对象的标识

`==`靠`__eq__`魔法方法实现

空值是Python里一个特殊的值，用`None`表示。`None`不能理解为`0`，因为`0`是有意义的，而`None`是一个特殊的空值。

在Python中，通常用全部大写的变量名表示常量：

python对变量重新赋值会开辟新的空间存储新值.对变量赋值`x = y`是把变量`x`指向真正的对象，该对象是变量`y`所指向的。随后对变量`y`的赋值*不影响*变量`x`的指向。

`//`除法只取结果的整数部分

在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。

对于单个字符的编码，Python提供了`ord()`函数获取字符的整数表示，`chr()`函数把编码转换为对应的字符：

`len()`函数计算的是`str`的字符数，如果换成`bytes`，`len()`函数就计算字节数：用`len()`函数可以获得list元素的个数：

replace()方法

### str

Python还允许用`r''`表示`''`内部的字符串默认不转义

1. 在Python中，采用的格式化方式和C语言是一致的，用`%`实现,print('%2d-%02d' % (3, 1))

2. str.format()   它会用传入的参数依次替换字符串内的占位符`{0}`、`{1}`……，

   ！符号，这个只在fromat中有用,{!r} , !r直接返回对象本体

3. `f-string`，它和普通字符串不同之处在于，字符串如果包含`{xxx}`，就会以对应的变量替换


str.join : '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'

参数为可迭代的，将其中的每个元素用指定符号分开，并返回字符串



### list、tuple元组

tuple一旦初始化就不能修改，只有1个元素的tuple定义时必须加一个逗号`,`，来消除歧义

tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向`'a'`，就不能改成指向`'b'`，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！

对于元组操作 t *= 2, 相当于t = t * 2，等号右边新创建了一个对象，又重新赋值给t，但是原来的元组本身是没有变的

由于list是可变对象，使用list的方法一般直接改变原对象，而str是不可变对象，使用str的方法不改变原str，而是返回新的str

元组拆包可以用于任何可迭代对象，当其位于赋值号右边时，是主动拆包，不使用`*`

### dict、set

dict在其他语言中也称为map


for i in dict    每个i只是键，不包括值

避免key不存在的错误1. ·'Thomas' in d 判断     2. 通过dict提供的`get()`方法，如果key不存在，可以返回`None`

要删除一个key，用`pop(key)`方法，对应的value也会从dict中删除

dict内部存放的顺序和key放入的顺序是没有关系的

dict的key必须是**不可变对象**。

dict的key必须是**不可变对象**。同样，集合中存放的也必须是不可变对象。

set构造函数必须接收iterable对象，比如，，，，**内置的序列类型都是接受可迭代对象作为参数**

```python
s = set(1)   #错误
s = set([1]) #正确
```


set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

set和dict的唯一区别仅在于没有存储对应的value

重复元素在set中自动被过滤

set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作

s1 & s2

s1 | s2

方法：

add(key)方法可以添加元素到set中

`remove(key)`方法可以删除元素





## 循环语句

Python的循环有两种，一种是for...in循环，for i in list，在循环内部修改i的值，不会改变list

`range()`函数，可以生成一个整数序列，再通过`list()`函数可以转换为list。比如`range(5)`生成的序列是从0开始小于5的整数：

第二种循环是while循环

在循环中，`break`语句可以提前退出循环，也可以通过`continue`语句，跳过当前的这次循环，直接开始下一次循环。

## 函数

函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：

pass语句可以在函数中做占位符

参数检查 instance(x, (int, float))

返回值：在语法上，返回一个tuple可以省略括号，而**多个变量可以同时接收一个tuple**，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple

### 函数参数

1. 位置参数：最一般的参数，按照位置传递值，位置参数的必选的
2. 默认参数：在定义函数时给参数设置默认值。
   - 在定义函数时，默认参数必须放在位置参数后面，否则调用函数传递参数时会产生歧义
   - 默认参数必须指向不可变对象，（默认参数不能是list）
3. 可变参数：在定义函数时在参数前加`*`，例如`*args`，args是list或tuple，在定义函数中，仍然把args当作list或tuple，但是在调用函数时需要将args解体,或者传入`*args`
   - 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple
4. 关键字参数：定义函数时形式参数`**kw`， kw是dict，在定义函数中，仍然把kw当作dict，但是在调用函数时需要传入`**kw`，或key=value...
   - 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。
5. 命名关键字参数：如果要限制关键字参数的名字，就可以用命名关键字参数. 不常用

高阶函数：接受函数作为参数，或者吧函数作为结果返回的函数

函数内省：自己检查自己，即通过内置函数查看自身属性，参数等

重载函数：函数名相同，参数不同的两个函数。python不支持重载函数

### 函数参数

1. 位置参数：最一般的参数，按照位置传递值，位置参数的必选的, 位置参数也可以当作关键字参数传入，此时位置可以随意

2. 默认参数：在定义函数时给参数设置默认值。
   - 在定义函数时，默认参数必须放在位置参数后面，否则调用函数传递参数时会产生歧义
   - 默认参数必须指向不可变对象，（默认参数也是一个变量）（默认参数不能是list）
   
   位置参数和默认参数应该都属于定位参数，默认参数传入时不需要加键
   
3. 可变参数：在定义函数时在参数前加`*`，例如`*args`，args是list或tuple，在定义函数中，仍然把args当作list或tuple，但是在调用函数时需要将args解体,或者传入`*args`
   - 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple

4. 关键字参数：定义函数时形式参数`**kw`， kw是dict，在定义函数中，仍然把kw当作dict，但是在调用函数时需要传入`**kw`，或key=value...
   - 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。
   - 关键字参数传入，同名键会绑定到对应的具名参数上，其余的被`**kw`捕获

5. 命名关键字参数（仅限关键字参数）：如果要限制关键字参数的名字，就可以用命名关键字参数. 

   这个很重要，很常见


**参数定义的顺序**必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数

**对于任意函数，都可以通过类似`func(*args, **kw)`的形式调用它，无论它的参数是如何定义的。**


python唯一支持的参数传递模式是共享传参，即传递的是参数的引用的副本，即函数内部的形参是实参的别名

`参数的引用的副本`: 给原对象一个新引用并传递引用（相当于下面b=a）b是形参

因此a如果是可变类型，可能会被修改。但是参数重新绑定对函数外部没有影响，比如

```
a = [1, 2, 3]
b = a
b = [1, 2]
```

引用和浅复制

```python
a = [1, 2, 3]
b = a   #a, b引用同一个列表
c = list(a)  #c d都是浅复制
d = a[:]
```

函数或者实例化类接收可变参数（即容器序列参数），应仔细考虑是否希望修改传入的参数，如果不希望修改，就在函数内部创建一个参数的复制，类似c 、d

弱引用不会增加对象的引用数量。因此，弱引用不会妨碍所指对象被当作垃圾回收

弱引用的意义：保存对象的引用，但不保留对象本身

引用相当于一条鱼线

### 装饰器和闭包

装饰器的特性

1. 能把被装饰的函数替换成其他函数
2. 装饰器在加载模块时立即执行

装饰器装饰的函数实际上就是闭包函数

闭包

函数返回之后，它的本地作用域就一去不复返了

`__code__`属性包含编译后的函数体内保存的局部变量(co_varnames)和自由变量(co_freevars)

在函数内部为变量赋值(即重新绑定引用)会导致变量成为局部变量

装饰器函数保存的时闭包的引用



## Class

python中，万物皆对象

有了`__init__`方法，在创建实例的时候，就不能传入空的参数了，必须传入与`__init__`方法匹配的参数

如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 self.__name = name

在Python中，变量名类似`__xxx__`的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量

在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类

### 多态

```
def run_twice(animal):
    animal.run()
#animal是Animal类一个实例，对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了，则会调用该类自己的run()方法
```

我们来判断对象类型，使用`type()`函数,能用`type()`判断的基本类型也可以用`isinstance()`判断

如果要获得一个对象的所有属性和方法，可以使用`dir()`函数，它返回一个包含字符串的list

配合`getattr()`、`setattr()`以及`hasattr()`，我们可以直接操作一个对象的状态

由于Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过`self`变量(`__init__`).

传给`__init__`函数的参数除self以外，其他参数在实例化的时候必须传进去

可以直接在class中定义属性，这种属性是类属性，**归`Student`类所有**.我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。

```
由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
```

实例属性属于各个实例所有，互不干扰；

类属性属于类所有，所有实例共享一个属性；

不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。

### class高级

可以通过MethodType给实例绑定方法，给一个实例绑定的方法，对另一个实例是不起作用的

动态绑定允许我们在程序运行的过程中动态给class加上功能

为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的`__slots__`变量，来限制该class实例能添加的属性：

```
__slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```

`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的

除非在子类中也定义`__slots__`，这样，子类实例允许定义的属性就是自身的`__slots__`加上父类的`__slots__`。
除非在子类中也定义`__slots__`，这样，子类实例允许定义的属性就是自身的`__slots__`加上父类的`__slots__`。(狭槽)

Python内置的`@property`装饰器就是负责把一个方法变成属性调用的

self[k]会调用`__getitem__`方法，该方法失败之后会通过`__missing__`再查询一次

变量前面加一个下划线`_`,也表示内部属性，可以通过@property设置访问

## 实用技巧

1. help(函数名) 输出函数的帮助信息

`__doc__`生成对象的帮助文本，相当于help()

`__getitem__`使类型可以使用[ ]

`__str__`为print()提供支持，如果找不到`__str__`,就会调用`__repr__`方法

`__iter__`使成为可迭代，具体迭代细节可以自己在方法中定义

`__dict__`属性储存实例的属性
<<<<<<< HEAD
=======

eval ()函数会将字符串当做语句来执行, 比如

```python
a = "123"
type(a)
<class 'str'>
b = eval(a)
b
123
type(b)
<class 'int'>
v1_clone = eval(repr(v1)) #v1_clone是v1这个实例的克隆
```

自己定义的类一般都属于可变类型，不可哈希

类属性可以为实例属性提供默认值

@property装饰器把读值方法标记为特性(属性)

任何类只要实现了`__len__`和`__getitem__`两个方法，就可以看做是序列（鸭子类型）

内置的序列类型，切片得到的都是各自类型的新实例

## 实用技巧

1. help(函数名) 输出函数的帮助信息
2. eval() 返回表达式计算结果。\>>> eval('pow(2,2)') 
3. repr() 函数将对象转化为供解释器读取的形式。返回一个对象的 string 格式。
4. **globals()** 函数会以字典类型返回当前位置的全部全局变量。
>>>>>>> dev

eval ()函数会将字符串当做语句来执行, 比如

```python
a = "123"
type(a)
<class 'str'>
b = eval(a)
b
123
type(b)
<class 'int'>
v1_clone = eval(repr(v1)) #v1_clone是v1这个实例的克隆
```

自己定义的类一般都属于可变类型，不可哈希

类属性可以为实例属性提供默认值

@property装饰器把读值方法标记为特性(属性)

任何类只要实现了`__len__`和`__getitem__`两个方法，就可以看做是序列（鸭子类型）

内置的序列类型，切片得到的都是各自类型的新实例

## 实用技巧

1. help(函数名) 输出函数的帮助信息
2. eval() 返回表达式计算结果。\>>> eval('pow(2,2)') 
3. repr() 函数将对象转化为供解释器读取的形式。返回一个对象的 string 格式。
4. **globals()** 函数会以字典类型返回当前位置的全部全局变量。

shuffle 洗牌 [ˈʃʌfl] 

intersection  [ˌɪntəˈsekʃn] 交叉

syntax 语法[ˈsɪntæks] 

strip [strɪp] 脱去

annotation [ˌænəˈteɪʃn]  注解

bind  [baɪnd] 绑定

inspect  [ɪnˈspekt]  检查

partial [ˈpɑːʃl] 偏的，部分的

assignment 赋值

