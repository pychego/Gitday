## 基本数据类型

布尔值可以用`and`、`or`和`not`运算

### 运算符重载

禁止重载内置类型的运算符，并且(is、and、or、not)都禁止重载

运算符重载的作用是让用户定义的对象使用中辍运算符或一元运算符。operater模块以函数形式提供了Python的全部中辍运算符。

支持一元运算符只需实现相应的特殊方法即可

`-`     `__neg__`        一元取负运算符

`+`     `__pos__`      一元取正运算符

`~`     `__invert__`   对整数按位取反   `~x == -(x+1)`

增量赋值运算符：`+=`、`-=`、`*=`、`/=`,没有定义`+=`的特殊方法时，python会退一步调用`__add__`，就地方法也在P316

对于列表等可变对象，`a += b`就地修改a，而`a = a + b`会直接更改a的引用

== 元素符比较两个对象的值（对象中保存的数据），is比较对象的标识

`==`靠`__eq__`魔法方法实现

**python基本所有的中辍运算符全部在liuchangdepython 316**

调用运算符的特殊方法时，首先是正向方法调用，如果返回`NotImplemented`，则进一步进行反向方法调用

如果正向方法只处理同一类型的操作数，就没有必要定义反向方法

对于序列类型，`+` 通常要求两个操作数属于同一类型，而`+=`的右操作数往往可以是任何可迭代对象



空值是Python里一个特殊的值，用`None`表示。`None`不能理解为`0`，因为`0`是有意义的，而`None`是一个特殊的空值。

在Python中，通常用全部大写的变量名表示常量：

**python对变量重新赋值会开辟新的空间存储新值**.对变量赋值`x = y`是把变量`x`指向真正的对象，该对象是变量`y`所指向的。随后对变量`y`的赋值*不影响*变量`x`的指向。

`//`除法只取结果的整数部分

**在计算机内存中，统一使用Unicode编码，**当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。

对于单个字符的编码，Python提供了`ord()`函数获取字符的整数表示，`chr()`函数把编码转换为对应的字符：

`len()`函数计算的是`str`的字符数，如果换成`bytes`，`len()`函数就计算字节数：用`len()`函数可以获得list元素的个数：

replace()方法

### str

Python还允许用`r''`表示`''`内部的字符串默认不转义

1. 在Python中，采用的格式化方式和C语言是一致的，用`%`实现,print('%2d-%02d' % (3, 1))

2. str.format()   它会用传入的参数依次替换字符串内的占位符`{0}`、`{1}`……，

   ！符号，这个只在fromat中有用,{!r} , !r直接返回对象本体

   format() 函数把指定值格式化为指定格式

   ```python
   format(value, format)
   x = format(0.5, '%')
   ```

   

3. `f-string`，它和普通字符串不同之处在于，字符串如果包含`{xxx}`，就会以对应的变量替换


str.join : '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'

参数为可迭代的，将其中的每个元素用指定符号分开，并返回字符串



### list、tuple元组

tuple一旦初始化就不能修改，只有1个元素的tuple定义时必须加一个逗号`,`来消除歧义

**tuple所谓的“不变”是说，tuple的每个元素，指向永远不变**（这根鱼线永远不变）。即指向`'a'`，就不能改成指向`'b'`，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！

对于元组操作 t *= 2, 相当于t = t * 2，等号右边新创建了一个对象，又重新赋值给t，但是原来的元组本身是没有变的

由于list是可变对象，使用list的方法一般直接改变原对象，而str是不可变对象，使用str的方法不改变原str，而是返回新的str

**元组拆包可以用于任何可迭代对象**，当其位于赋值号右边时，是主动拆包，不使用`*`

### dict、set

dict在其他语言中也称为map

**for i in dict    每个i只是键，不包括值**

避免key不存在的错误1. ·'Thomas' in d 判断     2. 通过dict提供的`get()`方法，如果key不存在，可以返回`None`

要删除一个key，用`pop(key)`方法，对应的value也会从dict中删除

dict内部存放的顺序和key放入的顺序是没有关系的

dict的key必须是**不可变对象**。同样，集合中存放的也必须是不可变对象。

set构造函数必须接收iterable对象，比如，，，，**内置的序列类型都是接受可迭代对象作为参数**

```python
s = set(1)   #错误
s = set([1]) #正确
```


set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

set和dict的唯一区别仅在于没有存储对应的value

重复元素在set中自动被过滤

**set可以看成数学意义上的无序和无重复元素的集合**，因此，两个set可以做数学意义上的交集、并集等操作

s1 & s2

s1 | s2

方法：

.add(key)方法可以添加元素到set中

`.remove(key)`方法可以删除元素



## 循环语句

Python的循环有两种，**一种是for...in循环**，for i in list，在循环内部修改i的值，不会改变list(仔细想一想，当list里面都是hashable时，就是这样)

`range()`函数，可以生成一个整数序列，再通过`list()`函数可以转换为list。

**第二种循环是while循环**

在循环中，`break`语句可以提前退出循环，也可以通过`continue`语句，跳过当前的这次循环，直接开始下一次循环。

## 函数

函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：

（复制了函数的引用，即再加一条鱼线钓到同一条鱼，即**引用的副本**）

pass语句可以在函数中做占位符

参数检查 isinstance(x, (int, float))

返回值：在语法上，返回一个tuple可以省略括号，而**多个变量可以同时接收一个tuple**，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple

### 函数参数

1. 位置参数：最一般的参数，按照位置传递值，位置参数的必选的

2. 默认参数：在定义函数时给参数设置默认值。
   - 在定义函数时，默认参数必须放在位置参数后面，否则调用函数传递参数时会产生歧义
   - 默认参数必须指向不可变对象，（默认参数不能是list）
   
3. 可变参数：在定义函数时在参数前加`*`，例如`*args`，args是list或tuple，在定义函数中，仍然把args当作list或tuple，但是在调用函数时需要将args解体,或者传入`*args`

   - 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple

   `*`表达式主动使用的场所

   - 函数定义时形参
   - 函数调用时用于解体数组
   - 元组拆包时用于接收剩余数值，，，除此之外，还没有见到过使用`*`，一般的表达式中***[1, 2]**是错误的

4. 关键字参数：定义函数时形式参数`**kw`， kw是dict，在定义函数中，仍然把kw当作dict，但是在调用函数时需要传入`**kw`，或key=value...
   - 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。

5. 命名关键字参数：如果要限制关键字参数的名字，就可以用命名关键字参数. 这个很重要，很常见

高阶函数：接受函数作为参数，或者吧函数作为结果返回的函数

函数内省：自己检查自己，即通过内置函数查看自身属性，参数等

重载函数：函数名相同，参数不同的两个函数。python不支持重载函数


**参数定义的顺序**必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数

**对于任意函数，都可以通过类似`func(*args, **kw)`的形式调用它，无论它的参数是如何定义的。**


python唯一支持的参数传递模式是共享传参，即传递的是参数的引用的副本，即函数内部的形参是实参的别名

`参数的引用的副本`: 给原对象一个新引用并传递引用（相当于下面b=a）b是形参（如上所说，加了一根鱼线钓到同一条鱼）

因此a如果是可变类型，可能会被修改。但是参数重新绑定对函数外部没有影响，比如

```python
a = [1, 2, 3]
b = a
b = [1, 2]
```

引用和浅复制

```python
a = [1, 2, 3]
b = a   #a, b引用同一个列表
c = list(a)  #c d都是浅复制
d = a[:]
```

函数或者实例化类接收可变参数（即容器序列参数），应仔细考虑是否希望修改传入的参数，如果不希望修改，就在函数内部创建一个参数的复制，类似c 、d

弱引用不会增加对象的引用数量。因此，弱引用不会妨碍所指对象被当作垃圾回收

弱引用的意义：保存对象的引用，但不保留对象本身

**引用相当于一条鱼线**，变量相当于标签

### 装饰器和闭包

装饰器的特性

1. 能把被装饰的函数替换成其他函数，即一般情况下替换为闭包函数(即装饰器内部函数)
2. 装饰器在加载模块时立即执行

装饰器装饰的函数实际上就是闭包函数

闭包

函数返回之后，它的本地作用域就一去不复返了

`__code__`属性包含编译后的函数体内保存的局部变量(co_varnames)和自由变量(co_freevars)

在函数内部为变量赋值(即重新绑定引用)会导致变量成为局部变量，**这是对于闭包函数使用外部函数的变量而言的！！！**

fluentpythonP163 重新为变量绑定引用可以理解为自由变量的这根鱼线已经断了，找不到自由变量这条鱼了

装饰器函数保存的是闭包的引用

#### 高阶函数

map, filter 可以用列表推导式，生成器表达式替代

all(iterable, /) ,当可迭代对象的所有值都为真时，all函数返回真

## Class

python中，万物皆对象

有了`__init__`方法，在创建实例的时候，就不能传入空的参数了，**必须传入与`__init__`方法匹配的参数**

如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 self.__name = name

在Python中，变量名类似`__xxx__`的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，**特殊变量是可以直接访问的**，不是private变量

在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类

抽象基类特点：

- 继承类必须实现抽象基类的方法
- 抽象基类无法实例化
- 比如说香蕉、桃子是类，那么水果就是抽象基类

**鸭子类型** ：忽略对象的真正类型，转而关注对象有没有实现所需的方法、签名和语义。

在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。

**白鹅类型：** 与鸭子类型相对，使用isinstance()检查子类继承关系

### 继承

使用Mixin类实现多重继承要非常小心

- 首先它必须表示某一种功能，而不是某个物品，python 对于mixin类的命名方式一般以 Mixin, able, ible 为后缀(Mixin混入只是为了添加特定的某个功能)
- 其次它必须责任单一，如果有多个功能，那就写多个Mixin类，一个类可以继承多个Mixin，为了保证遵循继承的“is-a”原则，只能继承一个标识其归属含义的父类
- 然后，它不依赖于子类的实现
- 最后，子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。（比如飞机照样可以载客，就是不能飞了）

  **组合与继承**

优先使用组合而非继承

**组合**是使用**其他的类实例作为自己的一个属性**（Has-a 关系）

**子类\**继承\**父类的属性和方法**（Is a 关系）

**优先使用组合保持代码简单**

使用超类的方法：

- `super().method()` 调用该方法不用传入self参数，遵守mro
- 直接通过类名调用实例方法，此时需显式传入self对象

### 多态

```python
def run_twice(animal):
    animal.run()
#animal是Animal类一个实例，对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了，则会调用该类自己的run()方法
```

我们来判断对象类型，使用`type()`函数,能用`type()`判断的基本类型也可以用`isinstance()`判断

如果要获得一个对象的所有属性和方法，可以使用`dir()`函数，它返回一个包含字符串的list

配合`getattr()`、`setattr()`以及`hasattr()`，我们可以直接操作一个对象的状态

由于Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过`self`变量(`__init__`).

可以直接在class中定义属性，这种属性是类属性，**归`Student`类所有**. 类属性可以为实例属性提供默认值.我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性

也可以定义类方法，通过@classmethod，该方法的第一个参数默认是类本身



实例属性属于各个实例所有，互不干扰；**类属性属于类所有，所有实例共享一个属性；**

不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。

### class高级

可以通过MethodType给实例绑定方法，给一个实例绑定的方法，对另一个实例是不起作用的

动态绑定允许我们在程序运行的过程中动态给class加上功能，猴子补丁

为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的`__slots__`变量，来限制该class实例能添加的属性：

```
__slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```

`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的
除非在子类中也定义`__slots__`，这样，子类实例允许定义的属性就是自身的`__slots__`加上父类的`__slots__`。(狭槽)

Python内置的`@property`装饰器就是负责把一个方法变成属性调用的

self[k]会调用`__getitem__`方法，该方法失败之后会通过`__missing__`再查询一次

变量前面加一个下划线`_`,也表示内部属性，可以通过@property设置访问





## 实用技巧

1. help(函数名) 输出函数的帮助信息
2. eval() 返回表达式计算结果。\>>> eval('pow(2,2)') 
3. repr() 函数将对象转化为供解释器读取的形式。返回一个对象的 string 格式。
4. **globals()** 函数会以字典类型返回当前位置的全部全局变量。

`__doc__`生成对象的帮助文本，相当于help()

`__getitem__`使类型可以使用[ ]访问元素，迭代，使用in运算符

(如果没有`__iter__`和`__contains__`方法，python会调用`__getitem__`方法，设法让迭代和in运算符可用)

`__setitem__`是**可变序列协议**所需的方法

`__str__`为print()提供支持，如果找不到`__str__`,就会调用`__repr__`方法

`__iter__`使成为可迭代，具体迭代细节可以自己在方法中定义

`__dict__`属性储存实例的属性

`__init__`：在初始化实例时传入参数会调用该函数，参见fluentpythonP290

`__mro__`：方法解析顺序(Method Resolution Order),类属性，按照方法解析顺序向上游列出超类继承顺序

`__name__`: 类属性，返回类名，实例没有这个属性

dict.update() 覆盖参数类的属性和方法，方法本质上也是属性

**eval ()函数会将字符串当做语句来执行**, 比如

```python
a = "123"
type(a)
<class 'str'>
b = eval(a)
b             //这个例子很深入！！！
123
type(b)
<class 'int'>
v1_clone = eval(repr(v1)) #v1_clone是v1这个实例的克隆
```

自己定义的类一般都属于可变类型，不可哈希

@property装饰器把读值方法标记为特性(属性)

任何类只要实现了`__len__`和`__getitem__`两个方法，就可以看做是序列（鸭子类型）

内置的序列类型，切片得到的都是各自类型的新实例

shuffle 洗牌 [ˈʃʌfl] 

intersection  [ˌɪntəˈsekʃn] 交叉

syntax 语法[ˈsɪntæks] 

strip [strɪp] 脱去

annotation [ˌænəˈteɪʃn]  注解

bind  [baɪnd] 绑定

inspect  [ɪnˈspekt]  检查

partial [ˈpɑːʃl] 偏的，部分的

assignment 赋值

