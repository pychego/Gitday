### 基本数据类型

布尔值可以用`and`、`or`和`not`运算

### 运算符重载

​	运算符重载的作用是让用户定义的对象使用中辍运算符或一元运算符。operater模块以函数形式提供了Python的全部中辍运算符。禁止重载内置类型的运算符，并且(is、and、or、not)都禁止重载

支持一元运算符只需实现相应的特殊方法即可

`-`     `__neg__`        一元取负运算符

`+`     `__pos__`      一元取正运算符

`~`     `__invert__`   对整数按位取反   `~x == -(x+1)`

增量赋值运算符：`+=`、`-=`、`*=`、`/=`,没有定义`+=`的特殊方法时，python会退一步调用`__add__`，就地方法也在P316

对于列表等可变对象，`a += b`就地修改a，而`a = a + b`会**直接更改a的引用**

**== 元素符比较两个对象的值（对象中保存的数据）**，is比较对象的标识（id）

`==`靠`__eq__`魔法方法实现

**python基本所有的中辍运算符全部在 fluent python 316**

调用运算符的特殊方法时，首先是正向方法调用，如果返回`NotImplemented`，则进一步进行反向方法调用

如果正向方法只处理同一类型的操作数，就没有必要定义反向方法，反向方法是为了处理类型不同的操作数...

对于序列类型，`+` 通常要求两个操作数属于同一类型，而`+=`的右操作数往往可以是任何可迭代对象，当操作元组和列表直接相加时报错两者不能`concatnate`，该单词即为linux中的cat。

空值是Python里一个特殊的值，用`None`表示。`None`不能理解为`0`，因为`0`是有意义的，而`None`是一个特殊的空值。

在Python中，通常用全部大写的变量名表示常量。

**python对变量重新赋值会开辟新的空间存储新值**.对变量赋值`x = y`是把变量`x`指向真正的对象，该对象是变量`y`所指向的。随后对变量`y`的赋值*不影响*变量`x`的指向。

`//`除法只取结果的整数部分， 地板除

**在计算机内存中，统一使用Unicode编码，**当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。

对于单个字符的编码，Python提供了`ord()`函数获取字符的整数(ASCII码)表示，`chr()`函数把编码转换为对应的字符：

`len()`函数计算的是`str`的字符数，如果换成`bytes`，`len()`函数就计算字节数；用`len()`函数可以获得list元素的个数

### str

Python还允许用`r''`表示`''`内部的字符串默认不转义

#### 格式化输出

1. 在Python中，采用的格式化方式和C语言是一致的，用`%`实现,print('%2d-%02d' % (3, 1))

2. str.format()   它会用传入的参数依次替换字符串内的占位符`{0}`、`{1}`……，

   ！符号，这个只在fromat中有用,{!r} , !r直接返回对象本体

   format() 函数把指定值格式化为指定格式

   ```python
   format(value, format)
   x = format(0.5, '%')   # 50.000000%
   ```

   

3. `f-string`它，写法和`r-string`相同；和普通字符串不同之处在于，字符串如果包含`{xxx}`，就会以对应的变量替换

`str.join` :    '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'，join函数的参数如果时列表，那么列表元素必须是字符串，如果参数是字符串，就用前面的内容连接字符串中的每个字符。

参数为可迭代的，将其中的每个元素用指定符号分开，并返回字符串



### list、tuple元组

tuple一旦初始化就不能修改，只有1个元素的tuple定义时必须加一个逗号`,`来消除歧义

**tuple所谓的“不变”是说，tuple的每个元素，指向永远不变**（这根鱼线永远不变）,是tuple中的每个元素的指向不变。即指向`'a'`，就不能改成指向`'b'`，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！

对于元组操作 t *= 2, 相当于t = t * 2，等号右边新创建了一个对象，又重新赋值给t，但是原来的元组本身是没有变的

由于list是可变对象，使用list的方法一般直接改变原对象，而str是不可变对象，使用str的方法不改变原str，而是返回新的str

**元组拆包可以用于任何可迭代对象**，当其位于赋值号右边时，是主动拆包，不使用`*`

在函数声明中如果想要使用元组，就需要使用`*`

### dict、set

dict在其他语言中也称为map

**for i in dict    每个i只是键，不包括值**

避免key不存在的错误1. ·'Thomas' in d 判断     2. 通过dict提供的`get()`方法，如果key不存在，可以返回`None`

```python
dictionary.update(iterable)  
# 参数中是对原字典的补充，如果有相同的就覆盖，不相同就加上
```



要删除一个key，用`pop(key)`方法，对应的value也会从dict中删除

dict内部存放的顺序和key放入的顺序是没有关系的

dict的key必须是**不可变对象**。同样，集合中存放的也必须是不可变对象。**set和dict的唯一区别仅在于没有存储对应的value**

set构造函数必须接收iterable对象，比如，，，，**内置的序列类型都是接受可迭代对象作为参数**

```python
s = set(1)  				 # 错误
s = set([1]) 				 # 正确
```


set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

重复元素在set中自动被过滤

**set可以看成数学意义上的无序和无重复元素的集合**，因此，两个set可以做数学意义上的交集、并集等操作

s1 & s2

s1 | s2

方法：dict的基本上所有方法都在 **fluet python P58**

.add(key)方法可以添加元素到set中

`.remove(key)`方法可以删除元素



## 循环语句

Python的循环有两种，**一种是for...in循环**，for i in list，在循环内部修改i的值，不会改变list(仔细想一想，当list里面都是hashable时，就是这样)

`range()`函数，可以生成一个整数序列，再通过`list()`函数可以转换为list。

**第二种循环是while循环**

在循环中，`break`语句可以提前退出循环，也可以通过`continue`语句，跳过当前的这次循环，直接开始下一次循环。

## 迭代器、生成器

**可迭代对象**：P334明确说明，可迭代对象一定不能是自身的迭代器。

**迭代器**：实现了`__iter__`和`__next__`, 自己写的类重构`__iter__`方法应该能够返回迭代器，惰性计算；迭代器只能前进不能后退

python从可迭代对象中获取迭代器。（通过iter()方法）

`enumerate(iterable, start=0)` 产出由两个元素组成的元组，结构是`(index, item)`, 其中index从start开始计时，item从iterable中获取

`return` 在生成器中，表示生成器运行完成了，可以结束了。然后生成器会抛出一个`StopIteration`的异常。(或执行到生成器末尾也会抛出错误)而`for`循环能够检测到这个异常，于是结束循环。在生成器里面的`return`只是一个结束标志，它不会把后面写的值返回给调用者。

## 函数

**函数名其实就是指向一个函数对象的引用**，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”(alias)：

（复制了函数的引用，即再加一条鱼线钓到同一条鱼，即**引用的副本**）

pass语句可以在函数中做占位符

参数检查 isinstance(x, (int, float))

返回值：在语法上，返回一个tuple可以省略括号，而**多个变量可以同时接收一个tuple**，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple

### 函数参数

1. 位置参数：最一般的参数，按照位置传递值，位置参数的必选的

2. 默认参数：在定义函数时给参数设置默认值。
   - 在定义函数时，默认参数必须放在位置参数后面，否则调用函数传递参数时会产生歧义
   - 默认参数必须指向不可变对象，（默认参数不能是list）
   
3. 可变参数：在定义函数时在参数前加`*`，例如`*args`，args是list或tuple，在定义函数中，仍然把args当作list或tuple，但是在调用函数时需要将args解体,或者传入`*args`

   - 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple

   `*`表达式主动使用的场所

   - 函数定义时形参
   - 函数调用时用于解体数组
   - 元组拆包时用于接收剩余数值，，，除此之外，还没有见到过使用`*`，一般的表达式中***[1, 2]**是错误的

4. 关键字参数：定义函数时形式参数`**kw`， kw是dict，在定义函数中，仍然把kw当作dict，但是在调用函数时需要传入`**kw`，或key=value...
   - 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。

5. 命名关键字参数：如果要限制关键字参数的名字，就可以用命名关键字参数. 这个很重要，很常见。命名关键字参数可以指定默认值，此时调用函数时可以不传递该参数，除此之外，必须同时传递键和值

**参数定义的顺序**必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数

**对于任意函数，都可以通过类似`func(*args, **kw)`的形式调用它，无论它的参数是如何定义的。**

---

高阶函数：接受函数作为参数，或者把函数作为结果返回的函数

函数内省：自己检查自己，即通过内置函数查看自身属性，参数等

重载函数：函数名相同，参数不同的两个函数。**python不支持重载函数**

---

python唯一支持的参数传递模式是共享传参，**即传递的是参数的引用的副本**，即函数内部的形参是实参的别名

python传递参数的方式：和Java是一样的（我没发现有什么区别），不说是按值传递或者是按引用传递了；**方法（函数）得到的是参数的副本，但是参数始终是引用。**举一个python的例子

可以把参数（或者说对象）当成鱼，引用当成鱼线

```python
def f1(arr):    
    arr.pop()
    
a = [1, 2, 3]
f1(a)
print(a)       # [1, 2] 传递的是引用的副本，相当于复制了一条鱼线钓到同一条鱼
```

```python
def f2(arr):
  arr = [4, 5, 6]
  
a = [1, 2, 3]
f2(a)
print(a)     # [1, 2, 3]  重新绑定，相当于复制的鱼线钓到了另外一条鱼
```

`参数的引用的副本`: 给原对象一个新引用并传递引用（相当于下面b=a）b是形参（如上所说，加了一根鱼线钓到同一条鱼）

因此a如果是可变类型，可能会被修改。但是**参数重新绑定对函数外部没有影响**，比如

```python
a = [1, 2, 3]
b = a
b = [1, 2]
```

引用和浅复制

```python
a = [1, 2, 3]
b = a 				  # a, b引用同一个列表
c = list(a)     # c d都是浅复制
d = a[:]
```

函数或者实例化类接收可变参数（即容器序列参数），应仔细考虑是否希望修改传入的参数，如果不希望修改，就在函数内部创建一个参数的复制，类似c 、d

弱引用不会增加对象的引用数量。因此，弱引用不会妨碍所指对象被当作垃圾回收

弱引用的意义：保存对象的引用，但不保留对象本身

**引用相当于一条鱼线**，变量相当于标签, 鱼是真正占用位置的，可能被回收

### 装饰器和闭包

装饰器的特性

1. 能把被装饰的函数替换成其他函数，即一般情况下替换为闭包函数(即装饰器内部函数)
2. 装饰器在加载模块时立即执行

装饰器装饰的函数实际上就是闭包函数

#### 闭包

函数返回之后，它的本地作用域就一去不复返了

`__code__`属性包含编译后的函数体内保存的局部变量(co_varnames)和自由变量(co_freevars)

在函数内部为变量赋值(即重新绑定引用)会导致变量成为局部变量，**这是对于闭包函数使用外部函数的变量而言的！！！**

fluent python P163 重新为变量绑定引用可以理解为自由变量的这根鱼线已经断了，找不到自由变量这条鱼了

装饰器函数保存的是闭包的引用

#### 高阶函数

map, filter 可以用列表推导式，生成器表达式替代

all(iterable, /) ,当可迭代对象的所有值都为真时，all函数返回真

## Class

python中，万物皆对象，对象即实例

有了`__init__`方法，在创建实例的时候，就不能传入空的参数了，**必须传入与`__init__`方法匹配的参数**

如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 self.__name = name

在Python中，变量名类似`__xxx__`的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，**特殊变量是可以直接访问的**，不是private变量

在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类

抽象基类特点：

- 继承类必须实现抽象基类所有的abstract方法
- 抽象基类无法实例化
- 比如说香蕉、桃子是类，那么水果就是抽象基类

**鸭子类型** ：忽略对象的真正类型，转而关注对象有没有实现所需的方法、签名和语义。

在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。

**白鹅类型：** 与鸭子类型相对，使用isinstance()检查子类继承关系

### 继承

使用Mixin类实现多重继承要非常小心

- 首先它必须表示某一种功能，而不是某个物品，python 对于mixin类的命名方式一般以 Mixin, able, ible 为后缀(Mixin混入只是为了添加特定的某个功能)
- 其次它必须责任单一，如果有多个功能，那就写多个Mixin类，一个类可以继承多个Mixin，为了保证遵循继承的“is-a”原则，只能继承一个标识其归属含义的父类
- 然后，它不依赖于子类的实现
- 最后，子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。（比如飞机照样可以载客，就是不能飞了）

  **组合与继承**

优先使用组合而非继承

**组合**是使用**其他的类实例作为自己的一个属性**（Has-a 关系）**描述符！！！！**

**子类继承父类的属性和方法**（Is a 关系）

**优先使用组合保持代码简单**

使用超类的方法：

- `super().method()` 调用该方法不用传入self参数，遵守mro,Method Resolution Order（方法解析顺序）
- 直接通过类名调用实例方法，此时需显式传入self对象

### 多态

```python
def run_twice(animal):
    animal.run()
# animal是Animal类一个实例，对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了，则会调用该类自己的run()方法
```

我们来判断对象类型，使用`type()`函数,能用`type()`判断的基本类型也可以用`isinstance()`判断

由于Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过`self`变量(`__init__`).

可以直接在class中定义属性，这种属性是类属性，**归`Student`类所有**. 类属性可以为实例属性提供默认值.我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性。

也可以定义类方法，通过@classmethod，该方法的第一个参数默认是类本身



实例属性属于各个实例所有，互不干扰；**类属性属于类所有，所有实例共享一个属性；**

不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。

### class高级

**python实例方法，类方法和静态方法**

静态方法：@staticmethod

类方法：@classmethod

可以通过MethodType给实例绑定方法，给一个实例绑定的方法，对另一个实例是不起作用的

动态绑定允许我们在程序运行的过程中动态给class加上功能，猴子补丁

为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的`__slots__`变量，来限制该class实例能添加的属性：

```python
__slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```

python类中的特殊方法实现是为了支持自建的对象可以使用常见的内建函数，从而统一接口。

`__call__` 类定义了这个方法之后，它的实例可以作为函数调用。

`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的
除非在子类中也定义`__slots__`，这样，子类实例允许定义的属性就是自身的`__slots__`加上父类的`__slots__`。(狭槽)

self[k]会调用`__getitem__`方法，该方法失败之后会通过`__missing__`再查询一次

变量前面加一个下划线`_`,也表示内部属性，可以通过@property设置访问

`__doc__`生成对象的帮助文本，相当于help()

`__len__`可以使对象使用`len(obj)`

`__getitem__`使类型可以使用[ ]访问元素，迭代，使用in运算符

`__contains__`    in运算符调用

(如果没有`__iter__`和`__contains__`方法，python会调用`__getitem__`方法，设法让迭代和in运算符可用)

`__setitem__`是**可变序列协议**所需的方法

`__str__`为str()和print()提供支持，如果找不到`__str__`,就会调用`__repr__`方法

`__repr__`: 控制台直接变量敲回车调用这个方法

`__iter__`使成为可迭代，具体迭代细节可以自己在方法中定义，for循环迭代调用的是`iter()`,而这个方法背后调用的是`__iter__`

`__dict__` 类和实例（类对象）都有这个属性，类的这个属性储存所有的类属性，实例的储存实例属性

`vars()`函数返回对象的`__dict__` 属性

```python
class Record:
    def __init__(self, **kwargs):
        self.__dict__.update(**kwargs)
# 这样传进去的关键字参数的关键字都会变成实例属性，可以直接用.使用
```

`__init__`：在初始化实例时传入参数会调用该函数，禁止返回任何值；参见fluentpythonP290

`__mro__`：方法解析顺序(Method Resolution Order),类属性，按照方法解析顺序向上游列出超类继承顺序

`__name__`: 类属性，返回类名，实例没有这个属性

`__new__`：类方法，是真正的构造方法

`__class__`: 对象所属类的引用。 `obj.__class__` 和 `type(obj)`作用相同

**处理属性的内置函数**

如果要获得一个对象的所有属性和方法，可以使用`dir()`函数，它返回一个包含字符串的list

配合`getattr()`、`setattr()`以及`hasattr()`，我们可以直接操作一个对象的状态

```python
hasattr(object, name)    # 用于判断对象是否包含对应的属性。
```

```python
getattr(object, name[, default])   # name必须写成字符串
```

**理解误区**

```python
# 这里的属性是指对象(类的实例)的属性，不是键，不是键，不是键！！！
a = {
    'b': 'b'
}
hasattr(a, 'keys')     # True
hasattr(a, 'b')        # False
```

`__getattr__` 仅当无法使用常规方式获取属性（即在实例、类或者超类中找不到指定的属性），解释器才会调用这个方法. 平时读取属性`obj.attr` 触发的是`__getattribute__`

## 元编程

​	元编程：编写的程序使用程序的运行时信息改变程序的行为。

在python中，数据的属性和处理数据的方法统称**属性**, 除此之外，可以通过**property**创建**特性**

通过`@property`装饰的方法都变成特性，使用时直接当作数据的属性使用

`propery`实际上是一个类

property构造方法的完整签名：

```python
property(fget=None, fset=None, fdel=None, doc=None)
# doc参数设置property对象的文档字符串
```

**读值方法** ： 有@property装饰器的方法

特性都是类属性，但是特性管理的是实例属性的存取;`'property' object is not callable`

**特性会覆盖实例属性**

​	`obj.attr`从特性开始寻找，之后才会在obj实例属性中寻找；注意，使用property实例赋值（特性工厂函数）和描述符的属性也属于特性（这里有点不懂）

```python
del obj.attr.  # 对象的属性可以用del语句删除
```

**覆盖型描述符和非覆盖型描述符**

​	前者实现了`__set__`方法，后者没有。

​    **覆盖性描述符**进行obj.attr进行读写操作时会由描述符接手，更容易理解的说法，设置托管实例的托管属性时会遭到拦截并覆盖相关操作。

   **非覆盖型描述符**，为实例属性赋值就是平常的，如果设置了同名的实例属性，则会覆盖描述符

描述符依附在类属性上，控制实例属性的的读写逻辑，但是无法控制类属性赋值操作。

**元类**

​	默认情况下，pyhton中的类是type类的实例。即type是大多数内置的类（包括自身）和用户自定义的类的元类

## 流程控制

当我们使用print(obj)在console上打印对象的时候，实质上调用的是sys.stdout.write(obj+'\n')

## os、sys、time

`os.path.join()`连接两个或更多的路径名

`os.cpu_count()`返回CPU数量

`sys.stdout`本来是控制台输出，可以把它重定向到文件`sys.stdout = fp`, print语句就直接输出到文件

`sys.stdout.flush()`强制其“刷新”缓冲区，这意味着它将把缓冲区中的所有内容都写到终端上

`time.sleep()`参数单位是秒

## 常用包

**tqdm** 

`tqdm.tqdm()`: 接收任意的可迭代对象，生成一个迭代器，使用这个迭代器时，**显示进度条动画**

**collections**

`Counter()` 这个实例可以当作计数器，初始化之后任意键的value均为0，需要时直接`+=`

## 实用技巧

1. help(函数名) 输出函数的帮助信息
2. eval() 返回表达式计算结果。\>>> eval('pow(2,2)') 
3. repr() 函数将对象转化为供解释器读取的形式。返回一个对象的 string 格式。
4. **globals()** 函数会以字典类型返回当前位置的全部全局变量。



dict.update() 覆盖参数类的属性和方法，方法本质上也是属性

**eval ()函数会将字符串当做语句来执行**, 比如

```python
a = "123"
type(a)
<class 'str'>
b = eval(a)
b             //这个例子很深入！！！
123
type(b)
<class 'int'>
v1_clone = eval(repr(v1))         # v1_clone是v1这个实例的克隆
```

自己定义的类一般都属于可变类型，不可哈希

@property装饰器把读值方法标记为特性(属性)

任何类只要实现了`__len__`和`__getitem__`两个方法，就可以看做是序列（鸭子类型）

内置的序列类型，切片得到的都是各自类型的新实例

shuffle 洗牌 [ˈʃʌfl] 

intersection  [ˌɪntəˈsekʃn] 交叉

syntax 语法[ˈsɪntæks] 

strip [strɪp] 脱去

annotation [ˌænəˈteɪʃn]  注解

bind  [baɪnd] 绑定

inspect  [ɪnˈspekt]  检查

partial [ˈpɑːʃl] 偏的，部分的

assignment 赋值

predicate  [ˈpredɪkət , ˈpredɪkeɪt]  断言，使基于

async 异步
